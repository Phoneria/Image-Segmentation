# -*- coding: utf-8 -*-
"""ASG3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/130yvf58HBUSId4ffFQStDcPxqC2ylDEr

# Import Libraries
"""

import os
import matplotlib.pyplot as plt
import numpy as np
import cv2
import PIL
from PIL import Image
import matplotlib.image as plt_image
from skimage import io
from skimage.segmentation import slic
from skimage.util import img_as_float
from skimage.segmentation import mark_boundaries
from scipy import ndimage
from skimage import data, color
from skimage.filters import gabor
import glob

# from sklearn.cluster import KMeans

from google.colab import drive

# Mount drive
drive.mount('/content/drive')

# Folder path
FOLDER_PATH = "/content/drive/MyDrive/Colab Notebooks/415ASG3/"
# Change the current working directory to 5the new directory
os.chdir(FOLDER_PATH)

"""# Change File Names"""

def list_files():
  """
  lists files in current directory
  """
  # Print the list of files
  for file in os.listdir(os.getcwd()):
      print(file)


def rename_files_with_number(directory_path : str):
    jpg_files = glob.glob(os.path.join(directory_path, '*.jpg'))
    print(jpg_files)
    for i, jpg_file in enumerate(jpg_files, 1):
        # Extract the file extension
        _, ext = os.path.splitext(jpg_file)

        # Create the new file name with an enumerated number
        new_name = f"{i}{ext}"

        # Construct the new path
        new_path = os.path.join(directory_path, new_name)

        # Rename the file
        os.rename(jpg_file, new_path)
        print(f'Renamed: {jpg_file} -> {new_path}')

"""
Do this if you want to try with changing iamge name from 1.jpg to 2.jpg easily
"""
# rename_files_with_number(FOLDER_PATH)
# list_files()

images = []

for i in os.listdir(os.getcwd()):
  if ".jpg"  in i:
    images.append(i)
print(images)

def show_image_gray(showing_img : np.ndarray, title : str = ""):
    """
    Plotting image
    """

    plt.imshow(showing_img,cmap = "gray")

    # Turn off axis labels and ticks
    plt.axis('off')

    plt.title(title)

    # Adjust layout to prevent clipping of titles
    plt.tight_layout()
    plt.show()

def show_image(showing_img : np.ndarray, title : str = ""):
    """
    Plotting image
    """

    plt.imshow(showing_img)

    # Turn off axis labels and ticks
    plt.axis('off')

    plt.title(title)

    # Adjust layout to prevent clipping of titles
    plt.tight_layout()
    plt.show()

def plot_4_image(image1,image2,image3,image4,title1,title2,title3,title4):

  # Plotting images in a 2x2 grid
  fig, axes = plt.subplots(nrows=2, ncols=2, figsize=(6, 6))

  # Plot 1
  axes[0, 0].imshow(image1)
  axes[0, 0].axis('off')
  axes[0, 0].set_title(title1)

  # Plot 2
  axes[0, 1].imshow(image2)
  axes[0, 1].axis('off')
  axes[0, 1].set_title(title2)

  # Plot 3
  axes[1, 0].imshow(image3)
  axes[1, 0].axis('off')
  axes[1, 0].set_title(title3)

  # Plot 4
  axes[1, 1].imshow(image4)
  axes[1, 1].axis('off')
  axes[1, 1].set_title(title4)

  # Adjust layout to prevent clipping of titles
  plt.tight_layout()

  # Show the plots
  plt.show()

"""# K Means"""

def k_means_image(img, image_array , k, n_init=10):
    # Randomly initialize centroids
    centroids = image_array[np.random.choice(image_array.shape[0], k, replace=False)]

    for _ in range(n_init):
        # Assign each pixel to the closest centroid
        distances = np.linalg.norm(image_array - centroids[:, np.newaxis], axis=2)
        labels = np.argmin(distances, axis=0)

        # Update centroids
        new_centroids = np.array([image_array[labels == j].mean(axis=0) for j in range(k)])

        # Check for convergence
        if np.all(centroids == new_centroids):
            break

        centroids = new_centroids

    # Map each pixel to its cluster centroid
    segmented_img = centroids[labels]
    #segmented_img = segmented_img.reshape(img.shape)

    return centroids, labels, segmented_img


#centroids, labels, segmented_img = k_means_image(img,img_array, k)

"""# Feature Extraction

## RGB

### Just RGB
"""

def show_segmented_image_rgb(image_file_name :str, k : int = 2, n_init = 10):
  """
  It takes image and k values that wanted to try as arguments and shows segmented images with RGB vectors for each element in k_list
  """
  # Read image
  img = plt_image.imread(image_file_name)

  # Flat image
  img_array = img.reshape(-1,3)

  # Normalization
  img_array = img_array / 255

  # Apply KMeans clustering
  centroids, labels, segmented_img = k_means_image(img,img_array, k)
  segmented_img = segmented_img.reshape(img.shape)

  return segmented_img

#show_image(show_segmented_image_rgb("2.jpg", k = 2)," k = 2, n_init = 10")

"""# Try with k = 2 and n_init = 10
for img in images :
  show_image(show_segmented_image_rgb(img, k = 2)," k = 2, n_init = 10")


# Try with k = 5 and n_init = 10
for img in images :
  show_image(show_segmented_image_rgb(img, k = 5)," k = 5, n_init = 10")


# Try with k = 2 and n_init = 50
for img in images :
  show_image(show_segmented_image_rgb(img, k = 2 , n_init = 50)," k = 2, n_init = 50")

### RGB & Location
"""

def show_segmented_image_rgbxy(image_file_name :str, k : int = 2, n_init = 10):
  """
  It takes image and k values that wanted to try as arguments and shows segmented images with RGB and location vectors for each element in k_list
  """

  img = plt_image.imread(image_file_name)

  # Convert the image to a NumPy array
  image_array = np.array(img)

  # Get the height, width, and channels of the image
  height, width, _ = image_array.shape

  # Create an array of pixel coordinates
  coordinates = np.array([[i/ height, j/width] for i in range(height) for j in range(width)])

  # Flatten the image array and coordinates array
  flattened_image = image_array.reshape(-1, 3)  # Assuming 3 channels (R, G, B)
  flattened_coordinates = coordinates.reshape(-1, 2)

  # Normalize array
  flattened_image = flattened_image / 255
  flattened_coordinates = flattened_coordinates

  # Concatenate the flattened arrays to create the final 2D array
  result_array = np.concatenate((flattened_image, flattened_coordinates), axis=1)

  # Apply KMeans clustering
  centroids, labels, segmented_img = k_means_image(img,result_array, k)

  # Accessing a specific row (pixel) in the result array
  sample_pixel_values = segmented_img[:, :3]  # R, G, B values


  final_img = sample_pixel_values.reshape(img.shape)

  return final_img

#show_image(show_segmented_image_rgbxy("2.jpg", k = 2)," k = 2, n_init = 10")

"""# Try with k = 2 and n_init = 10
for img in images:
  show_image(show_segmented_image_rgbxy(img, k = 2 , n_init = 10)," k = 2, n_init = 10")

# Try with k = 5 and n_init = 10
for img in images:
  show_image(show_segmented_image_rgbxy(img, k = 5 , n_init = 10)," k = 5, n_init = 10")

## SLIC

### SLIC Mean
"""

def mean_SLIC(image : np.ndarray, n_segments=100, compactness=10, sigma=1):

  """
  It takes image as arguments extract superpixels by applying mean function and returns mean_color_image
  """

  # Convert the image to LAB color space. (Because the documentation said it works better for this method  xD )
  image_lab = cv2.cvtColor(image, cv2.COLOR_RGB2LAB)

  # Perform SLIC superpixel segmentation
  segments = slic(image_lab, n_segments = n_segments, compactness = compactness, sigma = sigma)

  # Create superpixel boundaries on the original image
  superpixel_boundaries = mark_boundaries(image, segments)

  # Calculate mean color for each superpixel
  superpixel_colors = []
  for segment_id in np.unique(segments):
      mask = (segments == segment_id)
      mean_color = np.mean(image[mask], axis=0)
      superpixel_colors.append(mean_color)

  # Convert list to np array
  superpixel_colors = np.array(superpixel_colors, dtype=np.uint8)

  # Create an image with superpixels represented by mean colors
  mean_color_image = np.zeros_like(image)
  for segment_id, mean_color in zip(np.unique(segments), superpixel_colors):
      mean_color_image[segments == segment_id] = mean_color

  return  mean_color_image, segments, superpixel_boundaries

def KMeans_Mean_SLIC(image : np.ndarray, k : int, n_segments : int = 100):
  """
  Shows applied KMeans with different k values to  meaned and segmented image
  """

  # Apply mean fucntion to SLIC image
  mean_color_image, segments, superpixel_boundaries = mean_SLIC(image, n_segments = n_segments)

  # Flatting
  img_array = mean_color_image.reshape(-1,3)

  # Normalization
  img_array = img_array / 255

  # Apply KMeans clustering
  centroids, labels, segmented_img = k_means_image(image,img_array, k)
  segmented_img = segmented_img.reshape(image.shape)

  return segmented_img, mean_color_image , segments, superpixel_boundaries

"""
image = plt_image.imread("5.jpg")
segmented_img, mean_color_image , segments, superpixel_boundaries  = KMeans_Mean_SLIC(image, n_segments = 50, k = 2)
plot_4_image(image1 = image,image2 = superpixel_boundaries ,image3 = segments  ,image4 = segmented_img,title1 = "Original Image",title2 =  "Superpixel Boundaries",title3 = "Segments = 50",title4 = "Segmented Image with k = 2 & n_segments = 50")
"""

"""for img in images:
  image = plt_image.imread(img)
  segmented_img, mean_color_image , segments, superpixel_boundaries  = KMeans_Mean_SLIC(image, n_segments = 50, k = 2)

  plot_4_image(image1 = image,image2 = superpixel_boundaries ,image3 = segments  ,image4 = segmented_img,title1 = "Original Image",title2 =  "Superpixel Boundaries",title3 = "Segments = 50",title4 = "Segmented Image with k = 2 & n_segments = 50")

for img in images:
  image = plt_image.imread(img)
  segmented_img, mean_color_image , segments, superpixel_boundaries  = KMeans_Mean_SLIC(image, n_segments = 50, k = 5)
  show_image(segmented_img , " Segmented Image with k = 5 & n_segments = 50")

for img in images:
  image = plt_image.imread(img)
  segmented_img, mean_color_image , segments, superpixel_boundaries  = KMeans_Mean_SLIC(image, n_segments = 200, k = 5)

  show_image(segmented_img , " Segmented Image with k = 5 & n_segments = 200")

### SLIC &  Gabor Filter
"""

# Create a Gabor filter bank
def create_gabor_filters():
  ksize = 9
  sigma = [1.0, 5.0]
  theta = [0, np.pi/4]
  lambd = [1.0, 5.0]
  gamma = [0.1, 0.5]
  filters = []
  for s in sigma:
    for t in theta:
      for l in lambd:
        for g in gamma:
          kernel = cv2.getGaborKernel((ksize, ksize), s, t, l, g, 0, ktype=cv2.CV_64F)
          filters.append(kernel)

  return filters
# gabor_filters = create_gabor_filters()

def KMeans_Gabor_Bank(image_file_name : str, gabor_filters : list[np.ndarray] , num_segments = 100, num_clusters = 2):
  image = cv2.imread(image_file_name)

  # Apply SLIC for superpixel segmentation
  segments = slic(image, n_segments=num_segments, compactness=10)

  # Apply Gabor filters to each superpixel
  result = np.zeros_like(image, dtype=np.float64)
  for segment_id in np.unique(segments):
      mask = (segments == segment_id)
      superpixel = image.copy()
      superpixel[~mask] = 0  # Set non-superpixel pixels to zero

      responses = []
      for channel in range(3):  # Iterate over color channels
          for kernel in gabor_filters:
              response = cv2.filter2D(superpixel[:, :, channel], cv2.CV_64F, kernel)
              responses.append(response)

      # Take the mean of the Gabor filter responses
      mean_response = np.mean(responses, axis=0)

      # Assign the mean response to the corresponding pixels in the result
      result += np.dstack([mean_response]*3) * mask[:, :, np.newaxis]

  # Normalize the result to 8-bit for display
  result = (result / np.max(result) * 255).astype(np.uint8)

  # Reshape the image to a 2D array of pixels (flatten the image)
  img_array = result.reshape((-1, 3))

  # Apply K-Means clustering
  centroids, labels, segmented_img = k_means_image(image,img_array, k)


  # Reshape the image back to its original shape
  segmented_image = centroids[labels].reshape(result.shape)

  image1 = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
  image2 = mark_boundaries(cv2.cvtColor(image, cv2.COLOR_BGR2RGB), segments)
  image3 = cv2.cvtColor(result.astype(np.uint8), cv2.COLOR_BGR2RGB)
  image4 = segmented_image.astype(np.uint8)
  title1 = 'Original Image'
  title2 = 'Superpixel Boundaries'
  title3 = 'Result with Gabor Filters'
  title4 = f'Segmented Image, n_segments = {num_segments}, k = {num_clusters}'

  plot_4_image(image1, image2, image3, image4, title1, title2, title3, title4)



# gabor_filters = create_gabor_filters()
# KMeans_Gabor_Bank("4.jpg",gabor_filters = gabor_filters , num_segments = 50, num_clusters = 2)

"""for img in images:
  KMeans_Gabor_Bank(img,gabor_filters = gabor_filters , num_segments = 50, num_clusters = 2)

for img in images:
  KMeans_Gabor_Bank(img,gabor_filters = gabor_filters , num_segments = 200, num_clusters = 2)

for img in images:
  KMeans_Gabor_Bank(img,gabor_filters = gabor_filters , num_segments = 50, num_clusters = 5)"""